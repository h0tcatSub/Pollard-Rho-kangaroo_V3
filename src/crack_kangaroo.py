import random
from ECC import Point

import argparse
import numpy as np
import time

parser = argparse.ArgumentParser(description="How to Use crack_rho.py")
parser.add_argument("--x",
                    help="X coordinate (hexadecimal) of the elliptic curve cipher targeted for attack",
                    type=str,
                    required=True)
parser.add_argument("--y",
                    help="Y coordinate (hexadecimal) of the target elliptic curve cipher If all you have is the X coordinate, use the included compression tool to obtain the Y coordinate.",
                    type=str,
                    required=True)

parser.add_argument("--prime",
                    help="Modulo prime number (16 antilog) (default parameter used for secp256k1)",
                    type=str,
                    default="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F")
parser.add_argument("--order",
                    help="default parameter used for secp256k1",
                    type=str,
                    default="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141")
parser.add_argument("--bits_size",
                    help="Array length (decimal) The length of the array is generated by 2^bits_size",
                    type=int,
                    default=16)

def pollard_rho_factorization(n, limit=1000000):
    print("Performing Pollard's Rho factorization...")
    def f(x):
        return (x ** 2 + 1) % n

    x = random.randint(1, n - 1)
    y = x
    d = 1

    while d == 1:
        x = f(x)
        y = f(f(y))
        d = pow(abs(x - y), -1, n) % n

    return d if d != n else None

# Function to perform the Kangaroo algorithm with factors
def kangaroo_algorithm(g, h, n, factors, B):

    starttime = time.time()
    print("Performing Kangaroo algorithm...")
    P = 0
    Q = 0
    wild_kangaroos = [(random.randint(1, n - 1), random.randint(1, n - 1)) for _ in range(10)]  # Multiple parallel wild kangaroos
    wild_jump_size = random.randint(1, B // 10)  # Randomized wild kangaroo step size

    while True:
        for wild_x, wild_y in wild_kangaroos:
            print(P, B)
            u = wild_x
            v = wild_y
            for _ in range(wild_jump_size):
                u = (u * g) % n
                v = (v * h) % n
            d = pow(u - v, -1, n) % n
            if 1 < d < n:
                return d
            if d == 1:
                alpha = kangaroo_attack(P, Q, g, n, h, B)  # Using kangaroo_attack
                if alpha is not None:
                    print()
                    print(f"sol. time: {format((time.time()-starttime), '%.2f')} sec")
                    print()
                    print("Kamijo Touma >> Kill that illusion!!")
                    print()
                    return alpha
                P += B
                Q += B
            else:
                return d

def kangaroo_attack(P, Q, g, n, h, B, bits_size):
    def inv(g, n = n):
        return pow(g, -1, n)

    u = P
    v = Q
    u_iterations = np.arange(0, bits_size)
    v_iterations = np.arange(0, bits_size)
    while True:
        # Tame Kangaroo
        u = (u * g) % n
        u_iterations += bits_size

        # Wild Kangaroo
        v = (v * h) % n
        v_iterations += bits_size

        if np.any(u == v):
            g = np.where((u == v) == True)[0]
            alpha = (P - Q) * inv(g, n) % n  # Inverse of g modulo n
            return alpha

        if max(u_iterations, v_iterations) > B:
            # Maximum iterations reached without collision
            return None


def solve_rho(G, Y, bits_size):

    starttime = time.time()
    q = Y.order
    print(f'order = {q}')

    pub_keys = np.array([])
    for k in range(1, 4):
        pub_keys = np.append(pub_keys, G * k)

    if sum(np.isin(pub_keys, Y)) > 0:
        print(pub_keys)
        print()
        print(f"sol. time: {format((time.time()-starttime))} sec")
        print()
        print("Kamijo Touma >> Kill that illusion!!")
        key = np.where(pub_keys == Y)[0][0] + 1
        assert G * key == Y
        print(f"Private Key : 0x{format(key, '064x')}")
        print("[+] OK.")
        return key

    def new_xab(x, a, b, g, y, q):
        try:
            subset = Y.x % 3
        except ZeroDivisionError:
            subset = 2
        if subset == 0:
            return (x+x, (a*2) % q, (b*2) % q)
        if subset == 1:
            return (x+g, (a+1) % q, b        )
        if subset == 2:
            return (x+y, a        , (b+1) % q)
    x, a, b = Y, np.arange(bits_size), np.arange(bits_size)
    X, A, B = x, np.arange(bits_size), np.arange(bits_size)
    for i in range(1, q, bits_size):
        x, a, b = new_xab(x, a, b,  G, Y, q)
        X, A, B = new_xab(X, A, B,  G, Y, q)
        X, A, B = new_xab(X, A, B,  G, Y, q)
        print(f"{x} , {X}")
        if sum(np.isin(x, X)) > 0:
            print("[+] Found Collision Pair!!")
            break

    print()
    print(f"sol. time: {format((time.time()-starttime), '%.2f')} sec")
    print()
    print("Kamijo Touma >> Kill that illusion!!")
    print()
    res = ((a - A) * pow(B - b, -1, q)) % q
    if G * res == Y:
        print(f"Private Key : 0x{format(res, '064x')}")
        assert G * res == Y
        print("[+] OK.")
        return res

    return None

def main():
    args = parser.parse_args()
    p = int(args.prime, 16)
    n = int(args.order, 16)
    x = int(args.x, 16)
    y = int(args.y, 16)
    bits_size = 2 ** int(args.bits_size)
    G = Point(Point.Gx, Point.Gy)
    Q = Point(x, y)

    keys = np.arange(1, bits_size)
    G *= keys#np.append(pub_keys, G * k)
    print(G)
    try:
        factors = np.array([pollard_rho_factorization(number) for number in [Q.x, Q.y, Q.x + Q.y]])
        print("Factorization complete:", factors)
    except Exception as e:
        print("Error during factorization:", e)
    print("-" * 20)
    print()
    print(f"Modulo prime number   : {format(p, '064x')}")
    print(f"Order                 : {format(n, '064x')}")
    print(f"Point X               : {format(x, '064x')}")
    print(f"Point y               : {format(y, '064x')}")
    print()
    print("-" * 20)
    print()

    G = Point(Point.Gx, Point.Gy)
    private_key = kangaroo_algorithm(G, Q.y, n, factors, bits_size)
    assert G * private_key == Q #Final Check
    # ---- WIP ----
    print(f"Generating Public_keys.... ")
    print()
    print("[+] Start analysis... Kill that elliptic curve cryptography!!")
    #private_key = solve_rho(G, Q, bits_size)
    file = open("FOUND_KEYS.txt", "w+")
    file.writelines(format(private_key, '064x'))
    file.close()
    
if __name__ == "__main__":
    main()