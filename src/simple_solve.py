import random
from ECC_special import Point

import argparse
import numpy as np
import time

parser = argparse.ArgumentParser(description="How to Use crack_rho.py")
parser.add_argument("--x",
                    help="X coordinate (hexadecimal) of the elliptic curve cipher targeted for attack",
                    type=str,
                    required=True)
parser.add_argument("--y",
                    help="Y coordinate (hexadecimal) of the target elliptic curve cipher If all you have is the X coordinate, use the included compression tool to obtain the Y coordinate.",
                    type=str,
                    required=True)

parser.add_argument("--prime",
                    help="Modulo prime number (16 antilog) (default parameter used for secp256k1)",
                    type=str,
                    default="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F")
parser.add_argument("--order",
                    help="default parameter used for secp256k1",
                    type=str,
                    default="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141")
parser.add_argument("--bits_size",
                    help="Array length (decimal) The length of the array is generated by 2^bits_size",
                    type=int,
                    default=16)

def simple_solve(Gs, Y, Z, bits_size):
    e = Point(0, 0)
    progress = 0
    key = None
    starttime = time.time()
    while True:
        print(f"{progress} : {Gs[len(Gs) - 1]}")
        found_key = sum(Gs == Y) > 0#np.isin(Gs - Y.y, e)
        if found_key:
            print()
            print(f"sol. time: {format((time.time()-starttime), '.2f')} sec")
            print()
            key = int(np.where(Gs == Y)[0] + progress) + 1
            if random.randint(0, 100) >= 80: # 単純に楽しみたいだけ
                print("Accelerator >> It's a one-way street from here on out!!")
                print()
                print(f"Key : {format(key, '064x')}")
                return key
            print("Kamijo Touma >> Kill that illusion!!")
            print()
            print(f"Key : {format(key, '064x')}")
            return key
        Gs + Z # special method...
        progress += bits_size

def main():
    G = Point(Point.Gx, Point.Gy)
    p = G.modulo
    n = G.order
    x = 0x5b2c6b57cfdc1bf86dfaadc3c7b10b7bebe5c5e1e415ca92d740c58f3b62e88e#x
    y = 0x5df3b7f51bb5b17ad971a6d0886ebd8b55895e4a62e90c4571662ddbe02e7f5b#y
    Y = G * 0x10000#Point(x, y)
    bits_size = 2 ** 14 + 1#int(args.bits_size)
    keys = np.arange(1, bits_size)
    print(f"Generating Public_keys.... ")
    Gs = G * keys#np.append(pub_keys, G * k)
    Z  = G * bits_size
    print()
    print("[+] Start analysis... Kill that elliptic curve cryptography!!")
    print()
    print("-" * 20)
    print()
    print(f"Modulo prime number    : {format(p, '064x')}")
    print(f"Order                  : {format(n, '064x')}")
    print(f"Base X                 : {format(Point.Gx, '064x')}")
    print(f"Base Y                 : {format(Point.Gy, '064x')}")
    print(f"Point X                : {format(x, '064x')}")
    print(f"Point Y                : {format(y, '064x')}")
    print()
    print("-" * 20)
    print()

    private_key = simple_solve(Gs, Y, Z, bits_size)
    G = Point(Point.Gx, Point.Gy)
    print(f"G * {private_key} == Y")
    assert (G * private_key) == Y #Final Check
    print("[+] Assert OK.")
    file = open("FOUND_KEYS.txt", "w+")
    file.writelines(format(private_key, '064x'))
    file.close()
    
if __name__ == "__main__":
    main()