from ECC import Point

import argparse
import numpy as np
import time

parser = argparse.ArgumentParser(description="How to Use crack_rho.py")
parser.add_argument("--x",
                    help="X coordinate (hexadecimal) of the elliptic curve cipher targeted for attack",
                    type=str,
                    required=True)
parser.add_argument("--y",
                    help="Y coordinate (hexadecimal) of the target elliptic curve cipher If all you have is the X coordinate, use the included compression tool to obtain the Y coordinate.",
                    type=str,
                    required=True)

parser.add_argument("--prime",
                    help="Modulo prime number (16 antilog) (default parameter used for secp256k1)",
                    type=str,
                    default="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F")
parser.add_argument("--order",
                    help="default parameter used for secp256k1",
                    type=str,
                    default="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141")
parser.add_argument("--bits_size",
                    help="Array length (decimal) The length of the array is generated by 2^bits_size",
                    type=int,
                    default=16)

def solve_rho(G, Y, bits_size):

    starttime = time.time()
    q = Y.order()
    e = Point(0, 0)
    print(f'order = {q}')
    def new_xab(x, a, b, g, y, q):
        try:
            subset = Y.y % 3
        except ZeroDivisionError:
            subset = 2
        if subset == 0:
            return (x+x, (a*2) % q, (b*2) % q)
        if subset == 1:
            return (x+g, (a+1) % q, b        )
        if subset == 2:
            return (x+y, a        , (b+1) % q)
    x, a, b = Y, np.arange(bits_size), np.arange(bits_size)
    X, A, B = x, np.arange(bits_size), np.arange(bits_size)
    for i in range(1, q, bits_size):
        x, a, b = new_xab(x, a, b,  G, Y, q)
        X, A, B = new_xab(X, A, B,  G, Y, q)
        X, A, B = new_xab(X, A, B,  G, Y, q)
        print(f"{x} , {X}")
        if sum(np.isin((x - X))) > 0:
            print("[+] Found Collision Pair!!")
            break

    print()
    print(f"sol. time: {format((time.time()-starttime), '%.2f')} sec")
    print()
    print("Kamijo Touma >> Kill that illusion!!")
    print()
    res = ((a - A) * pow(B - b, -1, q)) % q
    if G * res == Y:
        print(f"Private Key : 0x{format(res, '064x')}")
        assert G * res == Y
        print("[+] OK.")
        return res

    return None


def main():
    args = parser.parse_args()
    p = int(args.prime, 16)
    n = int(args.order, 16)
    x = int(args.x, 16)
    y = int(args.y, 16)
    bits_size = 2 ** int(args.bits_size)
    G = Point()
    Q = Point(x, y)
    
    print("-" * 20)
    print()
    print(f"Prime   : {format(p, '064x')}")
    print(f"Order   : {format(n, '064x')}")
    print(f"Point X : {format(x, '064x')}")
    print(f"Point y : {format(y, '064x')}")
    print()
    print("-" * 20)
    print()
    # ---- WIP ----
    #keys = np.arange(1, bits_size)
    #for k in keys:
    #    pub_keys = np.append(pub_keys, G * k)
    #    print(f"Generating Public_keys.... [{k} / {bits_size}]", end="\r")
    print()
    print("[+] Start analysis... Kill that elliptic curve cryptography!!")
    private_key = solve_rho(G, Q, bits_size)
    file = open("FOUND_KEYS.txt", "w+")
    file.writelines(format(private_key, '064x'))
    file.close()
    
if __name__ == "__main__":
    main()